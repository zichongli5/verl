# Copyright 2024 Bytedance Ltd. and/or its affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Code to plot the pass@k results for the RepExp RL training results.
"""

import json
import os
from collections import defaultdict

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as stats
import seaborn as sns
from matplotlib.lines import Line2D

# Content configuration
EVAL_FOLDER = "./eval"
TASKS = ["math"]  # ["math", "gsm8k", "dapo-with-aime24"]
SEEDS = [41, 42, 43]
ALGORITHMS = ["elliptical"]  # ["grpo", "elliptical", "untrained", "unlikely"]
LOG_AXES = True

# Plot configuration
FACE_COLOR = "#F7F7FF"
MARKER = "o"
LINEWIDTH = 1.275
MARKERSIZE = 6
MARKEREDGEWIDTH = 0.9
LABEL_FONT_SIZE = 10
TITLE_FONT_SIZE = 11
TICK_LABEL_FONT_SIZE = 8
LEGEND_FONT_SIZE = 8

TASK_TO_NICE_NAME = {
    "math": "MATH",
    "gsm8k": "GSM8K",
    "dapo-with-aime24": "AIME 2024",
    "countdown-4": "Countdown",
}

ALGO_TO_COLOR = {
    "grpo": sns.color_palette("deep")[-1],
    "untrained": sns.color_palette("deep")[7],
    "elliptical": sns.color_palette("colorblind")[2],
    "unlikely": sns.color_palette("deep")[1],
}

ALGO_TO_NICE_NAME = {
    "grpo": "GRPO",
    "untrained": "Base Model",
    "elliptical": r"RepExp (ours)",
    "unlikely": "Unlikeliness",
}


def process_data(data: list[dict[str, float]], algorithm: str) -> tuple[dict[int, float], dict[int, float]]:
    """
    Process the pass@k data generated by a given algorithm.

    Args:
        data (List[Dict]): The data to process.
        algorithm (str): Algorithm that generated the data.

    Returns:
        Tuple[Dict[int, float], Dict[int, float]]:
            pass_at_k - The mean pass@k values.
            pass_at_k_sem - The standard error of the pass@k values.
    """
    pass_at_k = defaultdict(list)
    for d in data:
        for key, v in d.items():
            for k in [1, 2, 4, 8, 16, 32, 64, 128, 256]:
                if key.endswith(f"reward/pass@{k}/mean"):
                    pass_at_k[k].append(v)

    # NOTE: we only use a single seed for untrained since there is only one checkpoint for it
    if algorithm != "untrained":
        for k in pass_at_k.keys():
            assert len(pass_at_k[k]) == len(SEEDS)

    pass_at_k_sem = {k: stats.sem(v) for k, v in pass_at_k.items()} if algorithm != "untrained" else None
    pass_at_k = {k: np.mean(v) for k, v in pass_at_k.items()}

    return pass_at_k, pass_at_k_sem


def main():
    # Get all top-level folders in EVAL_FOLDER
    eval_folders = os.listdir(EVAL_FOLDER)

    # Figure setup
    sns.set_style("whitegrid")
    fig, axs = plt.subplots(1, len(TASKS), figsize=(3 * len(TASKS), 3))

    for i, task in enumerate(TASKS):
        ax = axs[i] if len(TASKS) > 1 else axs
        algo_to_xs = {}
        algo_to_ys = {}

        for algorithm in ALGORITHMS:
            # Get all eval folders for the current task and algorithm
            folders = [f for f in eval_folders if f.startswith(f"{task}_{algorithm}")]
            if len(folders) == 0:
                continue

            data = []
            for folder in folders:
                if algorithm == "untrained":
                    with open(os.path.join(EVAL_FOLDER, folder, "eval.json")) as f:
                        data.append(json.load(f))
                else:
                    # walk all files recursively in folder
                    for root, dirs, files in os.walk(os.path.join(EVAL_FOLDER, folder)):
                        for file in files:
                            if file.endswith("eval.json"):
                                with open(os.path.join(root, file)) as f:
                                    data.append(json.load(f))
                                break

            pass_at_k, pass_at_k_sem = process_data(data, algorithm)

            xs = np.array(list(pass_at_k.keys()))
            ys = np.array([pass_at_k[k] for k in xs])
            algo_to_xs[algorithm] = xs
            algo_to_ys[algorithm] = ys

            # Plot the current task - algorithm data
            ax.plot(
                xs,
                ys,
                color=ALGO_TO_COLOR[algorithm],
                label=algorithm,
                markeredgecolor=FACE_COLOR,
                marker=MARKER,
                linewidth=LINEWIDTH,
                markersize=MARKERSIZE,
                markeredgewidth=MARKEREDGEWIDTH,
                alpha=1.0 if algorithm != "untrained" else 0.8,
            )

            # Plot the standard error in shaded bands
            if algorithm != "untrained":
                sems = np.array([pass_at_k_sem[k] for k in xs])
                ax.fill_between(xs, ys - sems, ys + sems, alpha=0.2, color=ALGO_TO_COLOR[algorithm])

            # Set y-axis limits
            if task == "math":
                y_min = 0.7
                ax.set_ylim(top=0.95, bottom=y_min)
            elif task == "gsm8k":
                y_min = 0.925
                ax.set_ylim(top=0.995, bottom=y_min)
            elif task == "dapo-with-aime24":
                y_min = 0.1
                ax.set_ylim(bottom=y_min, top=0.63)

            # Set x-axis limits
            if LOG_AXES:
                ax.set_xlim(left=2 ** (-0.2), right=2 ** (8.2))
            else:
                ax.set_xlim(left=-10, right=266)

            # Set x-axis scale and ticks
            if LOG_AXES:
                ax.set_xscale("log", base=2)
                x_ticks = [2**i for i in range(int(np.log2(max(xs))) + 1)]
                x_tick_labels = [f"$2^{{{i}}}$" for i in range(int(np.log2(max(xs))) + 1)]
            else:
                # set every 64
                x_ticks = [1, 32, 64, 96, 128, 160, 192, 224, 256]
                x_tick_labels = ["1", "32", "64", "96", "128", "160", "192", "224", "256"]
            ax.set_xticks(x_ticks, x_tick_labels)

            # Set axes labels
            ax.set_xlabel("k", fontsize=LABEL_FONT_SIZE)
            if i == 0:
                ax.set_ylabel("Pass@k", fontsize=LABEL_FONT_SIZE)

            # Set title
            ax.set_title(f"{TASK_TO_NICE_NAME[task]}", fontsize=TITLE_FONT_SIZE)

        # Set font size for tick labels
        for _label in ax.get_xticklabels():
            _label.set_fontsize(TICK_LABEL_FONT_SIZE)
        for _label in ax.get_yticklabels():
            _label.set_fontsize(TICK_LABEL_FONT_SIZE)

    # Create legend handles
    legend_handles = [
        Line2D(
            [0],
            [0],
            color=ALGO_TO_COLOR[algo],
            marker=MARKER,
            linestyle="-",
            linewidth=LINEWIDTH,
            markersize=MARKERSIZE,
            markeredgewidth=MARKEREDGEWIDTH,
            markeredgecolor=FACE_COLOR,
            label=ALGO_TO_NICE_NAME[algo],
        )
        for algo in ALGORITHMS
    ]

    # Create legend
    legend = fig.legend(
        handles=legend_handles,
        loc="lower center",
        ncol=len(ALGORITHMS),
        bbox_to_anchor=(0.5, -0.07),
        fontsize=LEGEND_FONT_SIZE,
    )

    plt.tight_layout()

    os.makedirs("figures", exist_ok=True)
    # Save figure
    plt.savefig(
        os.path.join("figures", f"rl_pass_at_k_{TASKS}_{'' if LOG_AXES else '_linear_axes'}.pdf"),
        bbox_extra_artists=(legend,),
        bbox_inches="tight",
    )

    # Close figure
    plt.close()


if __name__ == "__main__":
    main()
